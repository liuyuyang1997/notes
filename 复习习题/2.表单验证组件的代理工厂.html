<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .error {
            border: 1px solid red;
            outline: none;
        }
    </style>
</head>

<body>
    <input type="text" validate rule="max:12,min:3">
    <input type="text" validate rule="max:3,isNumber">
</body>
<script>
    "use strict";
    class Validate {
        max(value, len) {
            return value.length <= len;
        }
        min(value, len) {
            return value.length >= len;
        }
        isNumber(value) {
            return /^\d+$/.test(value)
        }
    }
    let validate = new Validate();
    function ProxyFactory(target) {
        return new Proxy(target, {
            get(target, key) {
                console.log(target)
                return target[key]
            },
            set(target, key, el) {
                let rule = el.getAttribute('rule').split(',');
                // 这里使用 every 是因为 every是在每次循环都返回true时返回true
                // 与表单验证十分契合
                let flag = rule.every(item => {
                    const info = item.split(':')
                    return validate[info[0]](el.value, info[1])
                })
                //在验证返回假的时候 为元素添加错误样式 正确时去除
                el.classList[flag ? 'remove' : 'add']('error')
                return true; //严格模式下set需要返回true
            }
        })
    }
    const proxy = ProxyFactory(document.querySelectorAll('[validate]'))
    console.log(proxy)
    proxy.forEach((item, i) => {
        item.addEventListener('keyup', function () {
            proxy[i] = this; //此段代码没有改变值 只是为了触发set
        })
    });
</script>

</html>