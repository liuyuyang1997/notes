<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <pre>
        <!--三次握手-->
        前置知识
            序号（seq）代表了第一个要发送的字节编号
            确认号（ack）正确接收的编号
            ACK 确认标志位 为1 表示有效
            SYN 当字段为1时 表示连接请求 或 连接接收报文

        第一次握手 （SYN=1 seq=x） 
            客户端将SYN=1 产生一个随机序号X  并将数据包发送给服务端 客户端进入sent状态
        第二次握手 （SYN=1 ACK=1 ack=x+1 seq=y）
            服务端收到数据包后 由于SYN==1 知道客户端向建立连接 ack为X+1 表示对客户端x的确认
        第三次握手 （ACK=1 ack=y+1 seq=x+1）
            确认号（ask） 为 y+1 是对 服务端的确认
            此时 客户端 进入 established状态  服务端收到报文后也会进入 established状态

        <!--四次挥手-->
        客户端打算关闭连接 会发送 FIN 报文 (通知服务端要关闭连接) 客户端进入 wait1 状态  
        服务端收到报文后 向客户端发送 ACK 确认报文 (服务端知道客户端要关闭连接)   服务端进入 closed_wait状态
        客户端收到ACK报文后进入 wait2 状态
        服务端在处理完数据后向 客户端 发送 FIN报文 (告诉客户端数据处理完成,可以关闭连接) 服务端进入 LAST_ACK 状态
        客户端收到FIN报文后 向服务端发送 ACK报文 进入 time_wait状态
        服务端收到ACK后 进入 CLOSE 状态 至此 服务端以关闭连接
        客户端经过两倍的 MSL 时间之后 进入 CLOSE 状态 此时客户端也关闭了连接

        扩展
        1. 为什么握手三次 而挥手需要四次？
            握手是将第二次 第三次 进行了合并
            而挥手时 客户端向服务端发送FIN报文时 仅表示 客户端不在发送数据 但是还能接收数据
            服务端在收到FIN报文后 先回一个ACK报文 此时还有要处理和发送的数据 只有不再发送数据时 才发FIN给客户端
        2. 为什么客户端要等待两倍MSL时间 才关闭连接
        （MSL： 报文最大的生存时间）

        第一种情况：确保对方收到最后的ACK报文
            如果服务端没有收到客户端最后的ACK报文 超时后会重发FIN报文 此时等待时间确保了对方收到了最后的ACK报文
            在最坏的情况下 最后的ACK消息的最大存活时间+最后FIN消息的最大存活时间 就是 两倍的MSL
        第二种情况：防止新连接收到过期报文
            如果直接断开连接 网络中出现了迟到的数据包没被服务端接收
            此次在相同的端口与服务器发生新的连接  迟到的数据包会被认为是新的数据包
            因此等待两倍的MSL时间 足以让两个方向上的数据包都被丢弃 新连接就不会收到过期报文








        
    </pre>
</body>

</html>