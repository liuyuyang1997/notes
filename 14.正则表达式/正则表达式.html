<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // 检查字符串中的数字 2种方法
    // 1 字符串方法
    // let str = '111ddasdas234sadfadsf888'
    // let after = [...str].filter(item => !Number.isNaN(parseInt(item))).join('');
    // console.log(after)
    // 2正则表达式方法
    // 可以看出正则表达式的方法更加 简便 优美
    // console.log(str.match(/\d/g).join(''))

    // 正则表达式的两种声明方法
    // // 1 字面量方法
    // let str = '12313qwe123';
    // // 检查字符串中是否包括 字母u
    // // 这种方法无法在正则表达式里写变量
    // console.log(/u/.test(str)); //false 
    // // 但是可以使用eval() 写入变量
    // let a = 'q';
    // console.log(eval(`/${a}/`).test(str)); //true

    // // 2 对象方法创建
    // let str = '12313qwe123';
    // // 第一个参数是正则表达式 
    // // 第二个参数是模式 g代表 全局检查
    // let a = 'q'
    // let reg = new RegExp(a, 'g');
    // console.log(reg.test(str)); //true

    // 原子表匹配中文
    // let str = `
    // 	张三:024-4657339,
    // 	李四:024-4657339,
    // `;
    // // console.log(str.match(/[^\s\d:\-,]+/g)) // ["张三", "李四"]
    // // 另一种方法
    // console.log(str.match(/\p{sc=Han}+/gu)) // ["张三", "李四"]

    //选择符的使用
    // let str = '12313qwe123';
    // console.log(/6|1/.test(str)); //true 正则表达式的 '|' 与 '||' 类似 只要有一个为true 则返回真
    // console.log(/6|11/.test(str)); // false 选择符 判断的是竖线两侧的表达式 而不是两侧的单个字符
    // // 判断座机号码所属
    // let tel = '010-4657339';
    // console.log(/^(024|010)\-\d{7}$/.test(tel));

    // 转义
    // let price = 12.12
    // console.log(/^\d+\.?\d+$/.test(price))
    // //对象声明正则 需要多转义一次
    // console.log('\d' === 'd');  //true
    // let reg = new RegExp('^\\d+\\.?\\d+$'); //这里的参数是一个字符串 \d会被自动转换为d 所以转义两次
    // console.log(reg.test(price));

    // 匹配所有字符
    // let str = `
    //     fsadfdsa
    //     333
    //     xcv
    // `;
    // //利用原子表 和 大小写元字符 来实现
    // console.log(str.match(/[\d\D]+/));

    // 多行字符串处理
    // let str = `
    // 			# js,200rmb #
    // 			# php,70rmb #
    // 			# php#1323123
    // 			# html,10rmb #
    // 		`
    // //m 多行匹配修正符 会把字符串每一行 进行分别对待
    // let arr = str.match(/^\s+#\s.+#$/gm).map(item => {
    //     item = item.replace(/^\s+#\s+/, '').replace(/\s+#/, '');
    //     [name, price] = item.split(',');
    //     return { name, price }
    // });
    // console.log(JSON.stringify(arr, null, 2))

    //汉字与字符属性
    // let hd = "adsfadsf.撒旦法发……";
    // console.log(hd.match(/\p{L}/gu))
    // console.log(hd.match(/\p{P}/gu)); //[".", "…", "…"]
    // // Script 简写sc   语言系统
    // console.log(hd.match(/\p{sc=Han}/gu)); //["撒", "旦", "法", "发"]

    // 匹配宽字节  有些特殊字符一个字符不是两字节 而是多个字节
    // let str = "𝒳𝒴";
    // console.log(str.match(/[𝒳𝒴]/)); //"�"
    // console.log(str.match(/[𝒳𝒴]/u)); //"𝒳"

    // lastIndex 属性
    // let str = 'a';
    // let reg = /\w/g;
    // // console.log(str.match(reg)); //["a", "b", "c", "d", "e", "f", "g"] 没有看见索引等属性
    // // console.log(reg.lastIndex); //0
    // // console.log(reg.exec(str)); //["a", index: 0, input: "abcdefg", groups: undefined]
    // // console.log(reg.lastIndex) //1 每检查过一次 这个属性自动加1
    // // console.log(reg.exec(str)); //["b", index: 1, input: "abcdefg", groups: undefined]
    // while (res = reg.exec(str)) { //检测不到返回 false  跳出循环
    //     console.log(res)
    // }

    //y 模式
    // //全局 匹配 从字符串的第一个开始匹配 不符合则不再继续匹配
    // // y 模式的效率要高于 g 模式
    // let str = 'qq:111111111,222222222222,444444上的范德萨发的说法sad范德萨 大富士达方式的';
    // let reg = /(\d+),?/y;
    // // console.log(reg.exec(str)); //null 因为字符串第一个字符 水 不是数字
    // reg.lastIndex = 3;
    // let res = []
    // while (a = reg.exec(str)) res.push(a[1])
    // console.log(res); //["111111111", "222222222222", "444444"]

    // 区间匹配
    // [0-9]  代表0到9之间的所有数字  这个必须是升序  [9-0] 报错
    // [a-z]















    // 字符边界约束
    // ^ 开头  $ 结尾

    // 匹配模式
    // g 全局匹配
    // i 不区分大小写
    // s 将字符串视为单行 此时 换行被视为 普通空白  '.' 可以匹配出所有字符
    // m 多行匹配修正符 会把字符串每一行 进行分别对待
    // u 采用unicode时使用
    // y 全局 匹配 从字符串的第一个开始匹配 不符合则不再继续匹配

    // 原子表 []  原子组 ()
    // [^]  原子表开头带^ 代表除了原子表中的内容
    // [a-z] 代表所有小写字母
    // let reg = /[123456]/; //代表 1或者2或者3……
    // let reg2 = /(12|34)/; //代表 12 或 34

	// 		 12312`
    // console.log(str.match(/.+/))

    // . 除换行外任何字符
    // 元字符
    // 所有大写元字符均表示与小写相反的意思
    // \d 代表数字 0-9
    // \w 字母 数字 下划线 
    // \s 空白 空格 制表符 换行

    // 重复匹配
    // + 匹配1个 或多个
    // ? 0个 或多个

    // 正则.test(字符串)  有返回真 没有返回假
    // 字符串.match(正则) 有返回 匹配到的内容 返回类型是数组   没有返回null
    // let a = '111qqq5454qqq';
    // console.log(a.match(/\d{3,4}/g)); //["111", "5454"] 
</script>

</html>