<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        //没有原型的对象
        // 完全数据字典对象
        // let hd = Object.create(null, {
        //     name: { value: 'zs' }
        // })
        // console.log(hd)

        //原型方法与对象方法优先级  就近原则
        // let hd = {
        //     show() {
        //         console.log(111)
        //     }
        // };
        // // __proto__ 给长辈添加方法
        // hd.__proto__.show = function () {
        //     console.log(123)
        // }
        // hd.show() //111

        // console.dir() 打印对象全部方法

        // 函数有两个长辈 
        // __proto__  服务于这个函数
        // prototype 服务于函数实例化的对象
        // function User() {

        // }
        // let zs = new User();
        // console.log(User.prototype === zs.__proto__) //true 

        //系统构造函数的原型体现
        // let hd = {}; //Object
        // console.log(hd.__proto__ === Object.prototype); //true

        // let arr = []; //Array
        // console.log(arr.__proto__ === Array.prototype); //true

        // let str = '' //String
        // console.log(str.__proto__ === String.prototype); //true

        // let boolean = true; //Boolean
        // console.log(boolean.__proto__ === Boolean.prototype) //true

        // let reg = /a/i; // RegExp
        // console.log(reg.__proto__ === RegExp.prototype) //true


        // 自定义对象的原型设置
        // let son = { name: 'son' };
        // let parent = { name: 'parent' };
        // Object.setPrototypeOf(son, parent);
        // console.log(son);
        // console.log(Object.getPrototypeOf(son));//{ name: 'parent' }

        // 原型中 constructor 引用
        // function User(name) {
        //     this.name = name;
        // }
        // // User.prototype.show = function () {
        // //     console.log(123)
        // // }
        // User.prototype = {
        //     constructor: User,
        //     show() {
        //         console.log(444)
        //     }
        // }

        // let lisi = new User.prototype.constructor('lisi');
        // lisi.show()

        //使用一个对象 创建出另一个对象
        // 方法一
        // function User(name) {
        //     this.name = name;
        // }
        // User.prototype = {
        //     constructor: User,
        //     show() {
        //         console.log(444)
        //     }
        // }

        // let zs = new User();
        // let lisi = new zs.__proto__.constructor('lisi');
        // lisi.show()

        // 方法二
        // function User(name) {
        //     this.name = name;
        // }
        // let zs = new User()
        // function createObject(obj, ...args) {
        //     let constructor = Object.getPrototypeOf(obj).constructor
        //     return new constructor(...args)
        // }
        // let lisi = createObject(zs, '李四')
        // console.log(lisi)

        //属性检测 in 与 hasOwnProperty
        // let a = { name: 'zs' };
        // Object.prototype.web = 123;
        // console.log('web' in a);// true  in不仅会检测a对象 也会在a对象的原型链中寻找属性
        // //hasOwnProperty 只能在自己身上找属性

        // for (const key in a) {
        //     if (a.hasOwnProperty(key)) {
        //         console.log(key)
        //     }

        // }



        //使用 call 和 apply借用原型链    
        // let hd = {
        //     data: [1, 25, 11, 16, 55, 2, 3]
        // }
        // Object.setPrototypeOf(hd, {
        //     max() {
        //         return this.data.sort((a, b) => b - a)[0]
        //     }
        // })
        // console.log(hd.max()) //55
        // let lessons = {
        //     points: {
        //         css: 80,
        //         js: 99,
        //         php: 12,
        //     },
        //     get data() {
        //         return Object.values(this.points)
        //     }
        // }
        // // console.log(hd.max.apply(lessons))

        // //第二种方法 直接借用Math
        // console.log(Math.max.apply(null, Object.values(lessons.points)), 'math')
        // console.log(Math.max.call(null, ...Object.values(lessons.points)), 'call')


        // 合理的构造函数方法声明
        // function User(name) {
        //     this.name = name;
        //     this.show = function () {
        //         console.log(111);
        //     }
        // }
        // let zs = new User('张三')
        // let ls = new User('lisi')
        // console.log(zs)
        // console.log(ls)
        //这样写 每一个实例化的对象都含有一个方法 
        //改写
        // function User(name) {
        //     this.name = name;
        // }
        // User.prototype.show = function () {
        //     console.log(111);
        // }
        // let zs = new User('张三')
        // let ls = new User('lisi')
        // console.log(zs)
        // console.log(ls)

        // this 为调用属性的对象

        // 不要在 Object.prototype中追加方法  会导致代码不稳定·
    </script>
</body>

</html>